"""
Этап 2: Математика и жадные алгоритмы
Пример 3: Быстрое возведение в степень и модульная арифметика

Запустите этот файл, чтобы увидеть примеры работы с:
- Быстрым возведением в степень
- Модульной арифметикой
- Битовыми операциями

python3 03_fast_exponentiation.py
"""

print("=" * 60)
print("БЫСТРОЕ ВОЗВЕДЕНИЕ В СТЕПЕНЬ")
print("=" * 60)

# ============================================================
# 1. НАИВНОЕ ВОЗВЕДЕНИЕ В СТЕПЕНЬ
# ============================================================

print("\n1. НАИВНЫЙ ПОДХОД (медленно для больших степеней)")
print("-" * 60)


def power_naive(x, n):
    """
    Наивное возведение в степень
    Время: O(n)
    """
    result = 1
    for _ in range(n):
        result *= x
    return result


print(f"2^3 = {power_naive(2, 3)}")           # 8
print(f"3^4 = {power_naive(3, 4)}")           # 81
print(f"5^5 = {power_naive(5, 5)}")           # 3125

print("\nПроблема: O(n) - медленно для n=10^9")

# ============================================================
# 2. БЫСТРОЕ ВОЗВЕДЕНИЕ В СТЕПЕНЬ
# ============================================================

print("\n\n2. БЫСТРОЕ ВОЗВЕДЕНИЕ (O(log n))")
print("-" * 60)


def power_fast(x, n):
    """
    Быстрое возведение в степень
    Идея: x^n = (x^2)^(n/2) если n чётное
               x * x^(n-1) если n нечётное
    Время: O(log n)
    """
    if n == 0:
        return 1
    if n < 0:
        x = 1 / x
        n = -n

    result = 1
    current = x

    while n > 0:
        # Если n нечётное - умножаем на текущую степень
        if n % 2 == 1:
            result *= current

        # Возводим текущую степень в квадрат
        current *= current

        # Делим показатель на 2
        n //= 2

    return result


print(f"2^10 = {power_fast(2, 10)}")               # 1024
print(f"3^7 = {power_fast(3, 7)}")                 # 2187
print(f"2^(-3) = {power_fast(2, -3)}")             # 0.125

print("\nПошаговый разбор для 2^10:")
print("Бинарное представление 10 = 1010₂")
print("2^10 = 2^(8+2) = 2^8 * 2^2")
print("Шаг 1: n=10 (чётное), current = 2^1, result = 1")
print("Шаг 2: n=5 (нечётное), current = 2^2, result = 1 * 2^2 = 4")
print("Шаг 3: n=2 (чётное), current = 2^4, result = 4")
print("Шаг 4: n=1 (нечётное), current = 2^8, result = 4 * 2^8 = 1024")

# ============================================================
# 3. ВСТРОЕННАЯ ФУНКЦИЯ pow()
# ============================================================

print("\n\n3. ВСТРОЕННАЯ ФУНКЦИЯ pow()")
print("-" * 60)

print(f"pow(2, 10) = {pow(2, 10)}")              # 1024
print(f"pow(3, 7) = {pow(3, 7)}")                # 2187
print(f"pow(2, -3) = {pow(2, -3)}")              # 0.125

# С модулем (очень быстро!)
MOD = 10**9 + 7
print(f"\nС модулем 10^9+7:")
print(f"pow(2, 100, MOD) = {pow(2, 100, MOD)}")
print(f"pow(3, 1000, MOD) = {pow(3, 1000, MOD)}")

# ============================================================
# 4. МОДУЛЬНАЯ АРИФМЕТИКА
# ============================================================

print("\n\n4. МОДУЛЬНАЯ АРИФМЕТИКА")
print("-" * 60)

MOD = 10**9 + 7

print(f"Модуль: {MOD}")


def mod_operations():
    """Базовые операции с модулем"""
    a, b = 123456789, 987654321

    # Сложение
    add = (a + b) % MOD
    print(f"\n({a} + {b}) mod {MOD}")
    print(f"  = {add}")

    # Вычитание (важно: +MOD для положительного результата)
    sub = (a - b + MOD) % MOD
    print(f"\n({a} - {b}) mod {MOD}")
    print(f"  = {sub}")

    # Умножение
    mul = (a * b) % MOD
    print(f"\n({a} * {b}) mod {MOD}")
    print(f"  = {mul}")

    # Возведение в степень
    power = pow(a, b, MOD)
    print(f"\n{a}^{b} mod {MOD}")
    print(f"  = {power}")


mod_operations()

print("\n⚠️ ВАЖНО: Деление по модулю")
print("Нельзя просто делить! Нужен обратный элемент.")
print("a/b mod p = a * b^(-1) mod p")
print("b^(-1) = b^(p-2) mod p (по малой теореме Ферма, если p простое)")


def mod_div(a, b, mod):
    """
    Модульное деление
    a/b mod m = a * b^(m-2) mod m (если m простое)
    """
    # Находим обратный элемент: b^(-1) = b^(mod-2)
    b_inv = pow(b, mod - 2, mod)
    return (a * b_inv) % mod


a, b = 10, 3
result = mod_div(a, b, MOD)
print(f"\n10/3 mod {MOD} = {result}")

# ============================================================
# 5. БИТОВЫЕ ОПЕРАЦИИ ДЛЯ СТЕПЕНЕЙ 2
# ============================================================

print("\n\n5. БИТОВЫЕ ОПЕРАЦИИ (для степеней 2)")
print("-" * 60)


def is_power_of_two(n):
    """Проверка степени двойки"""
    return n > 0 and (n & (n - 1)) == 0


powers_of_2 = [1, 2, 4, 8, 16, 32, 64]
not_powers_of_2 = [3, 5, 6, 7, 12, 15]

print("Степени двойки:")
for num in powers_of_2:
    print(f"  {num:3d} = {bin(num):>10s} → {is_power_of_two(num)}")

print("\nНЕ степени двойки:")
for num in not_powers_of_2:
    print(f"  {num:3d} = {bin(num):>10s} → {is_power_of_two(num)}")

print("\nПочему работает n & (n-1) == 0?")
print("  Если n = 2^k, то в двоичном виде: 100...0")
print("  n-1 будет: 011...1")
print("  n & (n-1) = 000...0 = 0 ✓")

# ============================================================
# 6. ПРАКТИЧЕСКИЕ ПРИМЕРЫ
# ============================================================

print("\n\n6. ПРАКТИЧЕСКИЕ ПРИМЕРЫ")
print("-" * 60)

# Пример 1: Последняя цифра большой степени
print("\nПример 1: Найти последнюю цифру 2^100")
last_digit = pow(2, 100, 10)
print(f"Ответ: {last_digit}")
print(f"Объяснение: 2^100 mod 10 = {last_digit}")

# Пример 2: Остаток от деления на миллион
print("\nПример 2: Найти остаток от деления 3^1000 на 1000000")
remainder = pow(3, 1000, 1000000)
print(f"Ответ: {remainder}")

# Пример 3: Факториал по модулю
print("\nПример 3: Факториал 100 по модулю 10^9+7")


def factorial_mod(n, mod):
    """Факториал с модулем"""
    result = 1
    for i in range(2, n + 1):
        result = (result * i) % mod
    return result


fact_100 = factorial_mod(100, MOD)
print(f"100! mod {MOD} = {fact_100}")

# Пример 4: Количество способов (комбинаторика)
print("\nПример 4: C(1000, 500) mod 10^9+7")
print("(для этого нужна предварительная подготовка факториалов)")


def binomial_mod(n, k, mod):
    """
    Биномиальный коэффициент по модулю
    C(n,k) = n! / (k! * (n-k)!)
    """
    if k > n - k:
        k = n - k

    # Вычисляем числитель и знаменатель отдельно
    numerator = 1
    denominator = 1

    for i in range(k):
        numerator = (numerator * (n - i)) % mod
        denominator = (denominator * (i + 1)) % mod

    # Делим через обратный элемент
    return (numerator * pow(denominator, mod - 2, mod)) % mod


binom = binomial_mod(1000, 500, MOD)
print(f"C(1000, 500) mod {MOD} = {binom}")

# ============================================================
# 7. СРАВНЕНИЕ ПРОИЗВОДИТЕЛЬНОСТИ
# ============================================================

print("\n\n7. СРАВНЕНИЕ ПРОИЗВОДИТЕЛЬНОСТИ")
print("-" * 60)

import time


def benchmark():
    """Сравнение наивного и быстрого возведения"""
    n = 10000

    # Наивное
    start = time.time()
    result_naive = power_naive(2, n)
    time_naive = time.time() - start

    # Быстрое
    start = time.time()
    result_fast = power_fast(2, n)
    time_fast = time.time() - start

    # Встроенное
    start = time.time()
    result_builtin = pow(2, n)
    time_builtin = time.time() - start

    print(f"Возведение 2^{n}:")
    print(f"  Наивное:     {time_naive*1000:.4f} мс")
    print(f"  Быстрое:     {time_fast*1000:.4f} мс")
    print(f"  Встроенное:  {time_builtin*1000:.4f} мс")
    print(f"\nРазница: ~{time_naive/time_fast:.1f}x быстрее")


benchmark()

# ============================================================
# 8. ЗАДАЧИ ДЛЯ ПРАКТИКИ
# ============================================================

print("\n\n8. ЗАДАЧИ ДЛЯ ПРАКТИКИ")
print("-" * 60)

print("""
1. LeetCode #50 - Pow(x, n)
   https://leetcode.com/problems/powx-n/
   Реализуйте быстрое возведение в степень

2. LeetCode #372 - Super Pow
   https://leetcode.com/problems/super-pow/
   Возведение в степень с очень большим показателем

3. LeetCode #231 - Power of Two
   https://leetcode.com/problems/power-of-two/
   Проверка степени двойки (битовые операции)

4. Codeforces - Binary Exponentiation
   Задачи с тегом "math" и "bitmasks"
""")

print("\n" + "=" * 60)
print("ИТОГИ")
print("=" * 60)

print("""
✅ Быстрое возведение в степень: O(log n) вместо O(n)
✅ Модульная арифметика: всегда применяйте модуль к промежуточным результатам
✅ Деление по модулю: через обратный элемент (малая теорема Ферма)
✅ Битовые операции: для проверки степеней 2
✅ Встроенная pow(a, b, mod) - оптимизирована и быстра

Запомните: для больших чисел ВСЕГДА используйте модуль!
""")

print("=" * 60)
